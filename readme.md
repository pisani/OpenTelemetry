# OpenTelemetry Traceing for IRIS SOAP Services

## Overview
A customer recently asked if IRIS supported OpenTelemetry as they where seeking to measure and trace the time that IRIS implemented SOAP Services take to complete.  At this time, IRIS and related products do not natively support OpenTelemetry.  

It's true that InterSystems IRIS has several ways to capture, log and analyse the performance of a running instance, this information does not flow out of IRIS through to other components like Agents or Collectors within an implemented OpenTelemetry-supported stack.  Several technologies already support OpenTelemetry and it is fast becoming an adopted standard in the world of Observability.

Whilst there is ongoing development to natively support this observability standard in future IRIS releases, this article explains how, with the help of the Embedded Python and the corresponding Python libraries, IRIS application developers can start publishing Trace events to your OpenTelemetry back-ends with minimal effort.  More importantly, this gives my customer somethign to get up and running with today. 

## A brief note on Observability in general. 
Observability in generally comprises three main aspects:

## 
* Metrics capture, which is the capture of quantitative measuremements about the performance and behaiour of a system, similar to what IRIS publishes via its /api/monitor/metrics api
* Logging, which involves capturing and storing relevant information generated by an application or system, such as what appears in System Log outputs, or messages.log from IRIS instances.
* Tracing: which involves tracking the flow of a request or transaction as it moves through various components of a system. Distributed tracing allows you to follow the path of a request across multiple services, providing a visual representation of the entire transaction flow.
It is important to not that the focus of this article is solely on Traceing of SOAP Services.

## Approach for implementation:
Create a superclass with OpenTelemetry implementation which implementations of SOAP Services can simply subclass to adopt this framework.  Provision of Macros that can be used in user code to further contribute to observability and tracing. Minimal changes to the existing SOAP implementation should be needed.  The Diagram below illustrates this approach:







## Features:

* By default, every SOAP Service will be tracked. the OnPreWebMethod ensures this.
* The OnPreWebMethod will initialise the IRIS-side connection to the Observability Agent once, per (CSP) process, and identiy the system, the method, and start s default root span which times the execution of the soap service.
* The OnPostWebMethod will end the span.
* Users may override what default attributes (key/valu pairs) they would like to add to every default span
* Using $$$OTELLog(...), users may embelish their existing SOAP service implementations to add arbitrary logs within the current span
* Using $$$OTELPushChildSpan(...) users may decide to start a child span within the root span, to identify a seperate section of their code for observation. A collection of arbitrary key/value pairs can be logged on creation
* Using $$$OTELPopChildSpan(...) user may close the current child span, encompasing an isolated piece piece of code. 



# Installation of the sample code
Clone/git pull the repo into any local directory

```
$ git clone https://github.com/intersystems-community/OpenTelemetry-Trace-SOAP.git
```
Open a terminal window in this directory and type the following to build the IRIS images with sample code:

```
$ docker-compose build
```
Once the iris image is build, in the same directory type the following to start up the Jaeger and IRIS containers:

```
$ docker-compose up -d
```

This will startup two containers - the Jaeger OpenTelemetry target backend container (also exposing a user interface), and, an instance of IRIS which will server as the SOAP Web Services server endpoint.  Two simple webservices (that implement OpenTelemetry) have been included in the IRIS instance.

The IRIS instance hosts three simple SOAP Services:

* GetIRISVersion():   
Return the $ZV value of the IRIS instance
Other than the default functionality, no additonal observations are made
* Divide(a, b): 
This method takes two integers and returns the value of their division. It arbitrarily starts a child span, and within that a second nested span before completion,
Using $$$OTELPushChildSpan(..) macros available, the method identifies a span of code, wrapped around another span of code. These spans are visible as nested spand in the Jaeger UI
Using $$$OTELLog(..) arbitrary data is logged with the current span
* RunQuery() 
This method runs a query and tracks a span of time for Preparing the query and a subsequent (later) time period for Executing the query
Using $$$OTELPushChildSpan(..) macros available, the method identifies 2 independant, subsquent spans of code wrapped around Preperation and Execution of the query
These spans are visible as siblings in the Jaeger UI
Using $$$OTELLog(..) arbitrary data is logged with the current span

The Web service functionality is trivial and largely irrelevant, but serves to show telemetry tracing in action. 

## How to Test and view the results.
Generating trace information for the SOAP Web Methods can be done by building SOAP client (using your favourite technology) and then calling these services, just as any user or application would do in a real-world application. 

However - In order to simplify this process, and purely for demonstration purposes, we will leverage IRIS's helper CSP pages that allows us to call these SOAP methods from a browser:

Using your browser access the SOAP Information and testing pages via this URL. logging in as superuser/SYS if prompted:

```
http://localhost:52773/csp/irisapp/SOAP.MyService.cls
```
(Note: These pages are not enabled by default and security within the running IRIS instance had to be relaxed to enable this feature, for ease of testing)


Select each of the web methods you want to test, in order to generate SOAP activity.  To see this implementation generate an Error in the observed traces, use zero (0) as the second number in the Divide() SOAP method in order to force a <DIVDE> error.

Open another browser tab pull up the Jaeger UI via the following URL
'''
http://localhost:16686
'''
The resulting landing page shows you all services contributing telemetry readings and should look something similar to the screenshot below:
